# DO NOT EDIT: Autogenerated by /Users/micha/dev/docker-composer/src/docker_composer/_utils/generate_class.py
# for Docker Compose version v2.29.7-desktop.1

from typing import List, Optional

import attr

import docker_composer.runner.cmd.attach
import docker_composer.runner.cmd.build
import docker_composer.runner.cmd.config
import docker_composer.runner.cmd.cp
import docker_composer.runner.cmd.create
import docker_composer.runner.cmd.down
import docker_composer.runner.cmd.events
import docker_composer.runner.cmd.exec
import docker_composer.runner.cmd.images
import docker_composer.runner.cmd.kill
import docker_composer.runner.cmd.logs
import docker_composer.runner.cmd.ls
import docker_composer.runner.cmd.pause
import docker_composer.runner.cmd.port
import docker_composer.runner.cmd.ps
import docker_composer.runner.cmd.pull
import docker_composer.runner.cmd.push
import docker_composer.runner.cmd.restart
import docker_composer.runner.cmd.rm
import docker_composer.runner.cmd.run
import docker_composer.runner.cmd.scale
import docker_composer.runner.cmd.start
import docker_composer.runner.cmd.stats
import docker_composer.runner.cmd.stop
import docker_composer.runner.cmd.top
import docker_composer.runner.cmd.unpause
import docker_composer.runner.cmd.up
import docker_composer.runner.cmd.version
import docker_composer.runner.cmd.wait
import docker_composer.runner.cmd.watch
from docker_composer.base import DockerBaseRunner


@attr.s(auto_attribs=True)
class DockerComposeRoot(DockerBaseRunner):
    """
    Usage:  docker compose [OPTIONS] COMMAND
    Define and run multi-container applications with Docker
    Run 'docker compose COMMAND --help' for more information on a command.
    """

    all_resources: Optional[bool] = None
    """Include all resources, even those not used by services"""
    ansi: Optional[str] = None
    """Control when to print ANSI control characters ("never"|"always"|"auto") (default "auto")"""
    compatibility: Optional[bool] = None
    """Run compose in backward compatibility mode"""
    dry_run: Optional[bool] = None
    """Execute command in dry run mode"""
    env_file: Optional[list] = None
    """Specify an alternate environment file"""
    file: Optional[list] = None
    """Compose configuration files"""
    parallel: Optional[int] = None
    """Control max parallelism, -1 for unlimited (default -1)"""
    profile: Optional[list] = None
    """Specify a profile to enable"""
    progress: Optional[str] = None
    """Set type of progress output (auto, tty, plain, json, quiet) (default "auto")"""
    project_directory: Optional[str] = None
    """Specify an alternate working directory
       (default: the path of the, first specified, Compose file)"""
    project_name: Optional[str] = None
    """Project name"""
    _cmd: str = ""
    _options: List[str] = [
        "all_resources",
        "compatibility",
        "dry_run",
    ]

    def attach(
        self,
        detach_keys: Optional[str] = None,
        dry_run: Optional[bool] = None,
        index: Optional[int] = None,
        no_stdin: Optional[bool] = None,
        sig_proxy: Optional[bool] = None,
    ) -> docker_composer.runner.cmd.attach.DockerComposeAttach:
        """
        Usage:  docker compose attach [OPTIONS] SERVICE
        Attach local standard input, output, and error streams to a service's running container

        :param detach_keys: Override the key sequence for detaching from a container.
        :param dry_run: Execute command in dry run mode
        :param index: index of the container if service has multiple replicas.
        :param no_stdin: Do not attach STDIN
        :param sig_proxy: Proxy all received signals to the process (default true)
        """
        runner = docker_composer.runner.cmd.attach.DockerComposeAttach(
            **{k: v for k, v in locals().items() if k != "self"}
        )
        runner._parent_cmd = self._call_cmd()
        return runner

    def build(
        self,
        build_arg: Optional[list] = None,
        builder: Optional[str] = None,
        dry_run: Optional[bool] = None,
        memory: Optional[str] = None,
        no_cache: Optional[bool] = None,
        pull: Optional[bool] = None,
        push: Optional[bool] = None,
        quiet: Optional[bool] = None,
        ssh: Optional[str] = None,
        with_dependencies: Optional[bool] = None,
    ) -> docker_composer.runner.cmd.build.DockerComposeBuild:
        """
        Usage:  docker compose build [OPTIONS] [SERVICE...]
        Build or rebuild services

        :param build_arg: Set build-time variables for services
        :param builder: Set builder to use
        :param dry_run: Execute command in dry run mode
        :param memory: Set memory limit for the build container. Not supported by BuildKit.
        :param no_cache: Do not use cache when building the image
        :param pull: Always attempt to pull a newer version of the image
        :param push: Push service images
        :param quiet: Don't print anything to STDOUT
        :param ssh: Set SSH authentications used when building service images. (use 'default' for using your default SSH Agent)
        :param with_dependencies: Also build dependencies (transitively)
        """
        runner = docker_composer.runner.cmd.build.DockerComposeBuild(
            **{k: v for k, v in locals().items() if k != "self"}
        )
        runner._parent_cmd = self._call_cmd()
        return runner

    def config(
        self,
        dry_run: Optional[bool] = None,
        environment: Optional[bool] = None,
        format: Optional[str] = None,
        hash: Optional[str] = None,
        images: Optional[bool] = None,
        no_consistency: Optional[bool] = None,
        no_interpolate: Optional[bool] = None,
        no_normalize: Optional[bool] = None,
        no_path_resolution: Optional[bool] = None,
        output: Optional[str] = None,
        profiles: Optional[bool] = None,
        quiet: Optional[bool] = None,
        resolve_image_digests: Optional[bool] = None,
        services: Optional[bool] = None,
        variables: Optional[bool] = None,
        volumes: Optional[bool] = None,
    ) -> docker_composer.runner.cmd.config.DockerComposeConfig:
        """
        Usage:  docker compose config [OPTIONS] [SERVICE...]
        Parse, resolve and render compose file in canonical format

        :param dry_run: Execute command in dry run mode
        :param environment: Print environment used for interpolation.
        :param format: Format the output. Values: [yaml | json] (default "yaml")
        :param hash: Print the service config hash, one per line.
        :param images: Print the image names, one per line.
        :param no_consistency: Don't check model consistency - warning: may produce invalid Compose output
        :param no_interpolate: Don't interpolate environment variables
        :param no_normalize: Don't normalize compose model
        :param no_path_resolution: Don't resolve file paths
        :param output: Save to file (default to stdout)
        :param profiles: Print the profile names, one per line.
        :param quiet: Only validate the configuration, don't print anything
        :param resolve_image_digests: Pin image tags to digests
        :param services: Print the service names, one per line.
        :param variables: Print model variables and default values.
        :param volumes: Print the volume names, one per line.
        """
        runner = docker_composer.runner.cmd.config.DockerComposeConfig(
            **{k: v for k, v in locals().items() if k != "self"}
        )
        runner._parent_cmd = self._call_cmd()
        return runner

    def cp(
        self,
        archive: Optional[bool] = None,
        dry_run: Optional[bool] = None,
        follow_link: Optional[bool] = None,
        index: Optional[int] = None,
    ) -> docker_composer.runner.cmd.cp.DockerComposeCp:
        """
        Usage:  docker compose cp [OPTIONS] SERVICE:SRC_PATH DEST_PATH|-
                docker compose cp [OPTIONS] SRC_PATH|- SERVICE:DEST_PATH
        Copy files/folders between a service container and the local filesystem

        :param archive: Archive mode (copy all uid/gid information)
        :param dry_run: Execute command in dry run mode
        :param follow_link: Always follow symbol link in SRC_PATH
        :param index: Index of the container if service has multiple replicas
        """
        runner = docker_composer.runner.cmd.cp.DockerComposeCp(
            **{k: v for k, v in locals().items() if k != "self"}
        )
        runner._parent_cmd = self._call_cmd()
        return runner

    def create(
        self,
        build: Optional[bool] = None,
        dry_run: Optional[bool] = None,
        force_recreate: Optional[bool] = None,
        no_build: Optional[bool] = None,
        no_recreate: Optional[bool] = None,
        pull: Optional[str] = None,
        quiet_pull: Optional[bool] = None,
        remove_orphans: Optional[bool] = None,
        scale: Optional[str] = None,
    ) -> docker_composer.runner.cmd.create.DockerComposeCreate:
        """
        Usage:  docker compose create [OPTIONS] [SERVICE...]
        Creates containers for a service

        :param build: Build images before starting containers
        :param dry_run: Execute command in dry run mode
        :param force_recreate: Recreate containers even if their configuration and image haven't changed
        :param no_build: Don't build an image, even if it's policy
        :param no_recreate: If containers already exist, don't recreate them. Incompatible with --force-recreate.
        :param pull: Pull image before running ("always"|"missing"|"never"|"build") (default "policy")
        :param quiet_pull: Pull without printing progress information
        :param remove_orphans: Remove containers for services not defined in the Compose file
        :param scale: Scale SERVICE to NUM instances. Overrides the scale setting in the Compose file if present.
        """
        runner = docker_composer.runner.cmd.create.DockerComposeCreate(
            **{k: v for k, v in locals().items() if k != "self"}
        )
        runner._parent_cmd = self._call_cmd()
        return runner

    def down(
        self,
        dry_run: Optional[bool] = None,
        remove_orphans: Optional[bool] = None,
        rmi: Optional[str] = None,
        timeout: Optional[int] = None,
        volumes: Optional[bool] = None,
    ) -> docker_composer.runner.cmd.down.DockerComposeDown:
        """
        Usage:  docker compose down [OPTIONS] [SERVICES]
        Stop and remove containers, networks

        :param dry_run: Execute command in dry run mode
        :param remove_orphans: Remove containers for services not defined in the Compose file
        :param rmi: Remove images used by services. "local" remove only images that don't have a custom tag ("local"|"all")
        :param timeout: Specify a shutdown timeout in seconds
        :param volumes: Remove named volumes declared in the "volumes" section of the Compose file and anonymous volumes attached to containers
        """
        runner = docker_composer.runner.cmd.down.DockerComposeDown(
            **{k: v for k, v in locals().items() if k != "self"}
        )
        runner._parent_cmd = self._call_cmd()
        return runner

    def events(
        self, dry_run: Optional[bool] = None, json: Optional[bool] = None
    ) -> docker_composer.runner.cmd.events.DockerComposeEvents:
        """
        Usage:  docker compose events [OPTIONS] [SERVICE...]
        Receive real time events from containers

        :param dry_run: Execute command in dry run mode
        :param json: Output events as a stream of json objects
        """
        runner = docker_composer.runner.cmd.events.DockerComposeEvents(
            **{k: v for k, v in locals().items() if k != "self"}
        )
        runner._parent_cmd = self._call_cmd()
        return runner

    def exec(
        self,
        detach: Optional[bool] = None,
        dry_run: Optional[bool] = None,
        env: Optional[list] = None,
        index: Optional[int] = None,
        no_TTY: Optional[bool] = None,
        privileged: Optional[bool] = None,
        user: Optional[str] = None,
        workdir: Optional[str] = None,
    ) -> docker_composer.runner.cmd.exec.DockerComposeExec:
        """
        Usage:  docker compose exec [OPTIONS] SERVICE COMMAND [ARGS...]
        Execute a command in a running container

        :param detach: Detached mode: Run command in the background
        :param dry_run: Execute command in dry run mode
        :param env: Set environment variables
        :param index: Index of the container if service has multiple replicas
        :param no_TTY: Disable pseudo-TTY allocation. By default docker compose exec allocates a TTY. (default true)
        :param privileged: Give extended privileges to the process
        :param user: Run the command as this user
        :param workdir: Path to workdir directory for this command
        """
        runner = docker_composer.runner.cmd.exec.DockerComposeExec(
            **{k: v for k, v in locals().items() if k != "self"}
        )
        runner._parent_cmd = self._call_cmd()
        return runner

    def images(
        self,
        dry_run: Optional[bool] = None,
        format: Optional[str] = None,
        quiet: Optional[bool] = None,
    ) -> docker_composer.runner.cmd.images.DockerComposeImages:
        """
        Usage:  docker compose images [OPTIONS] [SERVICE...]
        List images used by the created containers

        :param dry_run: Execute command in dry run mode
        :param format: Format the output. Values: [table | json] (default "table")
        :param quiet: Only display IDs
        """
        runner = docker_composer.runner.cmd.images.DockerComposeImages(
            **{k: v for k, v in locals().items() if k != "self"}
        )
        runner._parent_cmd = self._call_cmd()
        return runner

    def kill(
        self,
        dry_run: Optional[bool] = None,
        remove_orphans: Optional[bool] = None,
        signal: Optional[str] = None,
    ) -> docker_composer.runner.cmd.kill.DockerComposeKill:
        """
        Usage:  docker compose kill [OPTIONS] [SERVICE...]
        Force stop service containers

        :param dry_run: Execute command in dry run mode
        :param remove_orphans: Remove containers for services not defined in the Compose file
        :param signal: SIGNAL to send to the container (default "SIGKILL")
        """
        runner = docker_composer.runner.cmd.kill.DockerComposeKill(
            **{k: v for k, v in locals().items() if k != "self"}
        )
        runner._parent_cmd = self._call_cmd()
        return runner

    def logs(
        self,
        dry_run: Optional[bool] = None,
        follow: Optional[bool] = None,
        index: Optional[int] = None,
        no_color: Optional[bool] = None,
        no_log_prefix: Optional[bool] = None,
        since: Optional[str] = None,
        tail: Optional[str] = None,
        timestamps: Optional[bool] = None,
        until: Optional[str] = None,
    ) -> docker_composer.runner.cmd.logs.DockerComposeLogs:
        """
        Usage:  docker compose logs [OPTIONS] [SERVICE...]
        View output from containers

        :param dry_run: Execute command in dry run mode
        :param follow: Follow log output
        :param index: index of the container if service has multiple replicas
        :param no_color: Produce monochrome output
        :param no_log_prefix: Don't print prefix in logs
        :param since: Show logs since timestamp (e.g. 2013-01-02T13:23:37Z) or relative (e.g. 42m for 42 minutes)
        :param tail: Number of lines to show from the end of the logs for each container (default "all")
        :param timestamps: Show timestamps
        :param until: Show logs before a timestamp (e.g. 2013-01-02T13:23:37Z) or relative (e.g. 42m for 42 minutes)
        """
        runner = docker_composer.runner.cmd.logs.DockerComposeLogs(
            **{k: v for k, v in locals().items() if k != "self"}
        )
        runner._parent_cmd = self._call_cmd()
        return runner

    def ls(
        self,
        all: Optional[bool] = None,
        dry_run: Optional[bool] = None,
        filter: Optional[str] = None,
        format: Optional[str] = None,
        quiet: Optional[bool] = None,
    ) -> docker_composer.runner.cmd.ls.DockerComposeLs:
        """
        Usage:  docker compose ls [OPTIONS]
        List running compose projects

        :param all: Show all stopped Compose projects
        :param dry_run: Execute command in dry run mode
        :param filter: Filter output based on conditions provided
        :param format: Format the output. Values: [table | json] (default "table")
        :param quiet: Only display IDs
        """
        runner = docker_composer.runner.cmd.ls.DockerComposeLs(
            **{k: v for k, v in locals().items() if k != "self"}
        )
        runner._parent_cmd = self._call_cmd()
        return runner

    def pause(
        self, dry_run: Optional[bool] = None
    ) -> docker_composer.runner.cmd.pause.DockerComposePause:
        """
        Usage:  docker compose pause [SERVICE...]
        Pause services

        :param dry_run: Execute command in dry run mode
        """
        runner = docker_composer.runner.cmd.pause.DockerComposePause(
            **{k: v for k, v in locals().items() if k != "self"}
        )
        runner._parent_cmd = self._call_cmd()
        return runner

    def port(
        self,
        dry_run: Optional[bool] = None,
        index: Optional[int] = None,
        protocol: Optional[str] = None,
    ) -> docker_composer.runner.cmd.port.DockerComposePort:
        """
        Usage:  docker compose port [OPTIONS] SERVICE PRIVATE_PORT
        Print the public port for a port binding

        :param dry_run: Execute command in dry run mode
        :param index: Index of the container if service has multiple replicas
        :param protocol: tcp or udp (default "tcp")
        """
        runner = docker_composer.runner.cmd.port.DockerComposePort(
            **{k: v for k, v in locals().items() if k != "self"}
        )
        runner._parent_cmd = self._call_cmd()
        return runner

    def ps(
        self,
        all: Optional[bool] = None,
        dry_run: Optional[bool] = None,
        filter: Optional[str] = None,
        format: Optional[str] = None,
        no_trunc: Optional[bool] = None,
        orphans: Optional[bool] = None,
        quiet: Optional[bool] = None,
        services: Optional[bool] = None,
        status: Optional[list] = None,
    ) -> docker_composer.runner.cmd.ps.DockerComposePs:
        """
        Usage:  docker compose ps [OPTIONS] [SERVICE...]
        List containers

        :param all: Show all stopped containers (including those created by the run command)
        :param dry_run: Execute command in dry run mode
        :param filter: Filter services by a property (supported filters: status)
        :param format: Format output using a custom template:
           'table':            Print output in table format with column headers (default)
           'table TEMPLATE':   Print output in table format using the given Go template
           'json':             Print in JSON format
           'TEMPLATE':         Print output using the given Go template.
           Refer to https://docs.docker.com/go/formatting/ for more information about formatting output with templates (default "table")
        :param no_trunc: Don't truncate output
        :param orphans: Include orphaned services (not declared by project) (default true)
        :param quiet: Only display IDs
        :param services: Display services
        :param status: Filter services by status. Values: [paused | restarting | removing | running | dead | created | exited]
        """
        runner = docker_composer.runner.cmd.ps.DockerComposePs(
            **{k: v for k, v in locals().items() if k != "self"}
        )
        runner._parent_cmd = self._call_cmd()
        return runner

    def pull(
        self,
        dry_run: Optional[bool] = None,
        ignore_buildable: Optional[bool] = None,
        ignore_pull_failures: Optional[bool] = None,
        include_deps: Optional[bool] = None,
        policy: Optional[str] = None,
        quiet: Optional[bool] = None,
    ) -> docker_composer.runner.cmd.pull.DockerComposePull:
        """
        Usage:  docker compose pull [OPTIONS] [SERVICE...]
        Pull service images

        :param dry_run: Execute command in dry run mode
        :param ignore_buildable: Ignore images that can be built
        :param ignore_pull_failures: Pull what it can and ignores images with pull failures
        :param include_deps: Also pull services declared as dependencies
        :param policy: Apply pull policy ("missing"|"always")
        :param quiet: Pull without printing progress information
        """
        runner = docker_composer.runner.cmd.pull.DockerComposePull(
            **{k: v for k, v in locals().items() if k != "self"}
        )
        runner._parent_cmd = self._call_cmd()
        return runner

    def push(
        self,
        dry_run: Optional[bool] = None,
        ignore_push_failures: Optional[bool] = None,
        include_deps: Optional[bool] = None,
        quiet: Optional[bool] = None,
    ) -> docker_composer.runner.cmd.push.DockerComposePush:
        """
        Usage:  docker compose push [OPTIONS] [SERVICE...]
        Push service images

        :param dry_run: Execute command in dry run mode
        :param ignore_push_failures: Push what it can and ignores images with push failures
        :param include_deps: Also push images of services declared as dependencies
        :param quiet: Push without printing progress information
        """
        runner = docker_composer.runner.cmd.push.DockerComposePush(
            **{k: v for k, v in locals().items() if k != "self"}
        )
        runner._parent_cmd = self._call_cmd()
        return runner

    def restart(
        self,
        dry_run: Optional[bool] = None,
        no_deps: Optional[bool] = None,
        timeout: Optional[int] = None,
    ) -> docker_composer.runner.cmd.restart.DockerComposeRestart:
        """
        Usage:  docker compose restart [OPTIONS] [SERVICE...]
        Restart service containers

        :param dry_run: Execute command in dry run mode
        :param no_deps: Don't restart dependent services
        :param timeout: Specify a shutdown timeout in seconds
        """
        runner = docker_composer.runner.cmd.restart.DockerComposeRestart(
            **{k: v for k, v in locals().items() if k != "self"}
        )
        runner._parent_cmd = self._call_cmd()
        return runner

    def rm(
        self,
        dry_run: Optional[bool] = None,
        force: Optional[bool] = None,
        stop: Optional[bool] = None,
        volumes: Optional[bool] = None,
    ) -> docker_composer.runner.cmd.rm.DockerComposeRm:
        """
        Usage:  docker compose rm [OPTIONS] [SERVICE...]
        Removes stopped service containers
        By default, anonymous volumes attached to containers will not be removed. You
        can override this with -v. To list all volumes, use "docker volume ls".
        Any data which is not in a volume will be lost.

        :param dry_run: Execute command in dry run mode
        :param force: Don't ask to confirm removal
        :param stop: Stop the containers, if required, before removing
        :param volumes: Remove any anonymous volumes attached to containers
        """
        runner = docker_composer.runner.cmd.rm.DockerComposeRm(
            **{k: v for k, v in locals().items() if k != "self"}
        )
        runner._parent_cmd = self._call_cmd()
        return runner

    def run(
        self,
        build: Optional[bool] = None,
        cap_add: Optional[list] = None,
        cap_drop: Optional[list] = None,
        detach: Optional[bool] = None,
        dry_run: Optional[bool] = None,
        entrypoint: Optional[str] = None,
        env: Optional[list] = None,
        interactive: Optional[bool] = None,
        label: Optional[list] = None,
        name: Optional[str] = None,
        no_TTY: Optional[bool] = None,
        no_deps: Optional[bool] = None,
        publish: Optional[list] = None,
        quiet_pull: Optional[bool] = None,
        remove_orphans: Optional[bool] = None,
        rm: Optional[bool] = None,
        service_ports: Optional[bool] = None,
        use_aliases: Optional[bool] = None,
        user: Optional[str] = None,
        volume: Optional[list] = None,
        workdir: Optional[str] = None,
    ) -> docker_composer.runner.cmd.run.DockerComposeRun:
        """
        Usage:  docker compose run [OPTIONS] SERVICE [COMMAND] [ARGS...]
        Run a one-off command on a service

        :param build: Build image before starting container
        :param cap_add: Add Linux capabilities
        :param cap_drop: Drop Linux capabilities
        :param detach: Run container in background and print container ID
        :param dry_run: Execute command in dry run mode
        :param entrypoint: Override the entrypoint of the image
        :param env: Set environment variables
        :param interactive: Keep STDIN open even if not attached (default true)
        :param label: Add or override a label
        :param name: Assign a name to the container
        :param no_TTY: Disable pseudo-TTY allocation (default: auto-detected) (default true)
        :param no_deps: Don't start linked services
        :param publish: Publish a container's port(s) to the host
        :param quiet_pull: Pull without printing progress information
        :param remove_orphans: Remove containers for services not defined in the Compose file
        :param rm: Automatically remove the container when it exits
        :param service_ports: Run command with all service's ports enabled and mapped to the host
        :param use_aliases: Use the service's network useAliases in the network(s) the container connects to
        :param user: Run as specified username or uid
        :param volume: Bind mount a volume
        :param workdir: Working directory inside the container
        """
        runner = docker_composer.runner.cmd.run.DockerComposeRun(
            **{k: v for k, v in locals().items() if k != "self"}
        )
        runner._parent_cmd = self._call_cmd()
        return runner

    def scale(
        self, dry_run: Optional[bool] = None, no_deps: Optional[bool] = None
    ) -> docker_composer.runner.cmd.scale.DockerComposeScale:
        """
        Usage:  docker compose scale [SERVICE=REPLICAS...]
        Scale services

        :param dry_run: Execute command in dry run mode
        :param no_deps: Don't start linked services
        """
        runner = docker_composer.runner.cmd.scale.DockerComposeScale(
            **{k: v for k, v in locals().items() if k != "self"}
        )
        runner._parent_cmd = self._call_cmd()
        return runner

    def start(
        self, dry_run: Optional[bool] = None
    ) -> docker_composer.runner.cmd.start.DockerComposeStart:
        """
        Usage:  docker compose start [SERVICE...]
        Start services

        :param dry_run: Execute command in dry run mode
        """
        runner = docker_composer.runner.cmd.start.DockerComposeStart(
            **{k: v for k, v in locals().items() if k != "self"}
        )
        runner._parent_cmd = self._call_cmd()
        return runner

    def stats(
        self,
        all: Optional[bool] = None,
        dry_run: Optional[bool] = None,
        format: Optional[str] = None,
        no_stream: Optional[bool] = None,
        no_trunc: Optional[bool] = None,
    ) -> docker_composer.runner.cmd.stats.DockerComposeStats:
        """
        Usage:  docker compose stats [OPTIONS] [SERVICE]
        Display a live stream of container(s) resource usage statistics

        :param all: Show all containers (default shows just running)
        :param dry_run: Execute command in dry run mode
        :param format: Format output using a custom template:
           'table':            Print output in table format with column headers (default)
           'table TEMPLATE':   Print output in table format using the given Go template
           'json':             Print in JSON format
           'TEMPLATE':         Print output using the given Go template.
           Refer to https://docs.docker.com/go/formatting/ for more information about formatting output with templates
        :param no_stream: Disable streaming stats and only pull the first result
        :param no_trunc: Do not truncate output
        """
        runner = docker_composer.runner.cmd.stats.DockerComposeStats(
            **{k: v for k, v in locals().items() if k != "self"}
        )
        runner._parent_cmd = self._call_cmd()
        return runner

    def stop(
        self, dry_run: Optional[bool] = None, timeout: Optional[int] = None
    ) -> docker_composer.runner.cmd.stop.DockerComposeStop:
        """
        Usage:  docker compose stop [OPTIONS] [SERVICE...]
        Stop services

        :param dry_run: Execute command in dry run mode
        :param timeout: Specify a shutdown timeout in seconds
        """
        runner = docker_composer.runner.cmd.stop.DockerComposeStop(
            **{k: v for k, v in locals().items() if k != "self"}
        )
        runner._parent_cmd = self._call_cmd()
        return runner

    def top(
        self, dry_run: Optional[bool] = None
    ) -> docker_composer.runner.cmd.top.DockerComposeTop:
        """
        Usage:  docker compose top [SERVICES...]
        Display the running processes

        :param dry_run: Execute command in dry run mode
        """
        runner = docker_composer.runner.cmd.top.DockerComposeTop(
            **{k: v for k, v in locals().items() if k != "self"}
        )
        runner._parent_cmd = self._call_cmd()
        return runner

    def unpause(
        self, dry_run: Optional[bool] = None
    ) -> docker_composer.runner.cmd.unpause.DockerComposeUnpause:
        """
        Usage:  docker compose unpause [SERVICE...]
        Unpause services

        :param dry_run: Execute command in dry run mode
        """
        runner = docker_composer.runner.cmd.unpause.DockerComposeUnpause(
            **{k: v for k, v in locals().items() if k != "self"}
        )
        runner._parent_cmd = self._call_cmd()
        return runner

    def up(
        self,
        abort_on_container_exit: Optional[bool] = None,
        abort_on_container_failure: Optional[bool] = None,
        always_recreate_deps: Optional[bool] = None,
        attach: Optional[list] = None,
        attach_dependencies: Optional[bool] = None,
        build: Optional[bool] = None,
        detach: Optional[bool] = None,
        dry_run: Optional[bool] = None,
        exit_code_from: Optional[str] = None,
        force_recreate: Optional[bool] = None,
        menu: Optional[bool] = None,
        no_attach: Optional[list] = None,
        no_build: Optional[bool] = None,
        no_color: Optional[bool] = None,
        no_deps: Optional[bool] = None,
        no_log_prefix: Optional[bool] = None,
        no_recreate: Optional[bool] = None,
        no_start: Optional[bool] = None,
        pull: Optional[str] = None,
        quiet_pull: Optional[bool] = None,
        remove_orphans: Optional[bool] = None,
        renew_anon_volumes: Optional[bool] = None,
        scale: Optional[str] = None,
        timeout: Optional[int] = None,
        timestamps: Optional[bool] = None,
        wait: Optional[bool] = None,
        wait_timeout: Optional[int] = None,
        watch: Optional[bool] = None,
    ) -> docker_composer.runner.cmd.up.DockerComposeUp:
        """
        Usage:  docker compose up [OPTIONS] [SERVICE...]
        Create and start containers

        :param abort_on_container_exit: Stops all containers if any container was stopped. Incompatible with -d
        :param abort_on_container_failure: Stops all containers if any container exited with failure. Incompatible with -d
        :param always_recreate_deps: Recreate dependent containers. Incompatible with --no-recreate.
        :param attach: Restrict attaching to the specified services. Incompatible with --attach-dependencies.
        :param attach_dependencies: Automatically attach to log output of dependent services
        :param build: Build images before starting containers
        :param detach: Detached mode: Run containers in the background
        :param dry_run: Execute command in dry run mode
        :param exit_code_from: Return the exit code of the selected service container. Implies --abort-on-container-exit
        :param force_recreate: Recreate containers even if their configuration and image haven't changed
        :param menu: Enable interactive shortcuts when running attached. Incompatible with --detach. Can also be enable/disable by
           setting COMPOSE_MENU environment var.
        :param no_attach: Do not attach (stream logs) to the specified services
        :param no_build: Don't build an image, even if it's policy
        :param no_color: Produce monochrome output
        :param no_deps: Don't start linked services
        :param no_log_prefix: Don't print prefix in logs
        :param no_recreate: If containers already exist, don't recreate them. Incompatible with --force-recreate.
        :param no_start: Don't start the services after creating them
        :param pull: Pull image before running ("always"|"missing"|"never") (default "policy")
        :param quiet_pull: Pull without printing progress information
        :param remove_orphans: Remove containers for services not defined in the Compose file
        :param renew_anon_volumes: Recreate anonymous volumes instead of retrieving data from the previous containers
        :param scale: Scale SERVICE to NUM instances. Overrides the scale setting in the Compose file if present.
        :param timeout: Use this timeout in seconds for container shutdown when attached or when containers are already running
        :param timestamps: Show timestamps
        :param wait: Wait for services to be running|healthy. Implies detached mode.
        :param wait_timeout: Maximum duration to wait for the project to be running|healthy
        :param watch: Watch source code and rebuild/refresh containers when files are updated.
        """
        runner = docker_composer.runner.cmd.up.DockerComposeUp(
            **{k: v for k, v in locals().items() if k != "self"}
        )
        runner._parent_cmd = self._call_cmd()
        return runner

    def version(
        self,
        dry_run: Optional[bool] = None,
        format: Optional[str] = None,
        short: Optional[bool] = None,
    ) -> docker_composer.runner.cmd.version.DockerComposeVersion:
        """
        Usage:  docker compose version [OPTIONS]
        Show the Docker Compose version information

        :param dry_run: Execute command in dry run mode
        :param format: Format the output. Values: [pretty | json]. (Default: pretty)
        :param short: Shows only Compose's version number
        """
        runner = docker_composer.runner.cmd.version.DockerComposeVersion(
            **{k: v for k, v in locals().items() if k != "self"}
        )
        runner._parent_cmd = self._call_cmd()
        return runner

    def wait(
        self, down_project: Optional[bool] = None, dry_run: Optional[bool] = None
    ) -> docker_composer.runner.cmd.wait.DockerComposeWait:
        """
        Usage:  docker compose wait SERVICE [SERVICE...] [OPTIONS]
        Block until containers of all (or specified) services stop.

        :param down_project: Drops project when the first container stops
        :param dry_run: Execute command in dry run mode
        """
        runner = docker_composer.runner.cmd.wait.DockerComposeWait(
            **{k: v for k, v in locals().items() if k != "self"}
        )
        runner._parent_cmd = self._call_cmd()
        return runner

    def watch(
        self,
        dry_run: Optional[bool] = None,
        no_up: Optional[bool] = None,
        prune: Optional[bool] = None,
        quiet: Optional[bool] = None,
    ) -> docker_composer.runner.cmd.watch.DockerComposeWatch:
        """
        Usage:  docker compose watch [SERVICE...]
        Watch build context for service and rebuild/refresh containers when files are updated

        :param dry_run: Execute command in dry run mode
        :param no_up: Do not build & start services before watching
        :param prune: Prune dangling images on rebuild
        :param quiet: hide build output
        """
        runner = docker_composer.runner.cmd.watch.DockerComposeWatch(
            **{k: v for k, v in locals().items() if k != "self"}
        )
        runner._parent_cmd = self._call_cmd()
        return runner
